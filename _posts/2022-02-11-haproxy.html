---
layout: post
title: Отказоустойчивый балансировщик HAProxy
date: '2022-02-11T17:19:00.007+03:00'
author: Rishat
tags:
- Linux
modified_time: '2022-02-14T18:58:06.507+03:00'
thumbnail: https://blogger.googleusercontent.com/img/a/AVvXsEjzLlGGnC2qPrax53b9LVWqHHlfSqGxuRhQeFf0MxaZRhBQ-H_d19xnP9KIxGn-ojD--0T4tbBBmPhi0Rw06a0z75hY-WdjDGUSYDfauqsI5ws42Oq541m08CRjBwOrpQunhqfDCEMX4FCxXa96auOu_D3NTurkL5-_VxR7cwFWrtsSlccbeDCkjSQzBQ=s72-w200-c-h158
blogger_id: tag:blogger.com,1999:blog-632559424411275764.post-8521474448423849758
blogger_orig_url: https://dxcpp.blogspot.com/2022/02/haproxy.html
---

<p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/a/AVvXsEjzLlGGnC2qPrax53b9LVWqHHlfSqGxuRhQeFf0MxaZRhBQ-H_d19xnP9KIxGn-ojD--0T4tbBBmPhi0Rw06a0z75hY-WdjDGUSYDfauqsI5ws42Oq541m08CRjBwOrpQunhqfDCEMX4FCxXa96auOu_D3NTurkL5-_VxR7cwFWrtsSlccbeDCkjSQzBQ=s890" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img alt="HAProxy Logo" border="0" data-original-height="700" data-original-width="890" height="158" src="https://blogger.googleusercontent.com/img/a/AVvXsEjzLlGGnC2qPrax53b9LVWqHHlfSqGxuRhQeFf0MxaZRhBQ-H_d19xnP9KIxGn-ojD--0T4tbBBmPhi0Rw06a0z75hY-WdjDGUSYDfauqsI5ws42Oq541m08CRjBwOrpQunhqfDCEMX4FCxXa96auOu_D3NTurkL5-_VxR7cwFWrtsSlccbeDCkjSQzBQ=w200-h158" title="HAProxy" width="200" /></a></div>Балансировщик layer 4 работает в качестве посредника между клиентом и сервером, выступая от имени первого. Помимо этого, он проверяет доступность хостов пулах бэкэнда и раскидывает по ним входящие клиентские запросы по установленному алгоритму балансировки. Чтобы сделать его отказоустойчивым, можно воспользоваться технологиями, предоставляющими функционал failover ip (например carp или vrrp или что-то другое).<span><a name='more'></a></span><p></p><h3 style="text-align: left;">Настройка</h3><p>Для начала нам понадобится два сервера с Debian 9. Это могут быть физические или виртуальные машины с единственным статическим ip-адресом на каждом.</p><p></p><ul style="text-align: left;"><li>Server 1: <span style="color: red;">192.168.0.1</span></li><li>Server 2: <span style="color: red;">192.168.0.2</span></li><li>failover ip: <span style="color: red;">192.168.0.3</span></li></ul><p></p><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">Ucarp</h3><div>Ucarp — свободная реализация протокола CARP, который позволяет нескольким серверам иметь дополнительный одинаковый ip-адрес из одной подсети. В конкретный момент времени адрес может быть активен только на одном сервере.</div><div><br /></div><h3 style="text-align: left;">Настройка Ucarp</h3><div><div>Установим утилиту командой:</div><div><span style="color: #2b00fe;">apt-get </span>install ucarp</div><div></div><blockquote><div>Примечание: небольшую справку и список обязательных/необязательных параметров вы можете увидеть в файле <span style="font-family: courier;">/usr/share/doc/ucarp/README.Debian</span>. Либо выполните команду <span style="font-family: courier;">ucarp —help.</span></div><div>Все настройки нужно прописывать в файле конфигурации сетевых настроек, открываем для редактирования <span style="font-family: courier;">/etc/network/interfaces</span> первого сервера:</div></blockquote><div></div><div><br /></div><div><span style="font-family: courier;">auto lo</span></div><div><span style="font-family: courier;">iface lo inet loopback</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">auto eth0</span></div><div><span style="font-family: courier;">allow-hotplug eth0</span></div><div><span style="font-family: courier;">iface eth0 inet static</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; address 192.168.0.1</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; netmask 255.255.255.0</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; gateway 192.168.0.254</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ucarp-vid 1</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ucarp-vip 192.168.0.3</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ucarp-password password</span></div><div><span style="font-family: courier;">iface eth0:ucarp inet static</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; address 192.168.0.3</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; netmask 255.255.255.0</span></div><div><br /></div><div>Конфигурация второго сервера будет отличаться лишь его собственным адресом, все остальное остается прежним:</div><div><br /></div><div><span style="font-family: courier;">auto lo</span></div><div><span style="font-family: courier;">iface lo inet loopback</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">auto eth0</span></div><div><span style="font-family: courier;">allow-hotplug eth0</span></div><div><span style="font-family: courier;">iface eth0 inet static</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; address 192.168.0.2</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; netmask 255.255.255.0</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; gateway 192.168.0.254</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ucarp-vid 1</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ucarp-vip 192.168.0.3</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ucarp-password password</span></div><div><span style="font-family: courier;">iface eth0:ucarp inet static</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; address 192.168.0.3</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; netmask 255.255.255.0</span></div><div><br /></div><div><blockquote>Примечание: отличаться также могут и имена интерфейсов, но в моем случае они совпали.</blockquote></div><div>Сохраняем конфигурацию, но сетку пока не перезапускаем.</div><div>Настройка ucarp на этом завершена. При отключении активного сервера, второй перехватит адрес за пару секунд. Вы можете включать в конфигурацию дополнительные опции, но для базового варианта рассмотренного выше более чем достаточно.</div></div><div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">Тестирование Ucarp</h3><div>Пришло время на обоих серверах выполнить команду:</div><div><span style="font-family: courier;">service networking restart</span></div><div><blockquote>Примечание: если вы выполняете работы на виртуальной машине Hyper-V, то не забудьте в дополнительных настройках сетевого интерфейса выставить галочку «Включить спуфинг MAC-адресов». В противном случае отказоустойчивый ip будет постоянно висеть активным на обоих ВМ. На других гипервизорах такого поведения не будет (p.s. VMWare не тестировал).</blockquote></div><div>… и проверить как адрес «гуляет» между хостами. Для этого не поленитесь запустить ping отказоустойчивого ip и по очереди перезагружать хосты по несколько раз. Операция очень простая, но её выполнение даст вам железную уверенность в том, что все отработает как нужно в случае неблагоприятного сценария.</div></div><div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">HAProxy</h3><div>Перед настройкой <a href="http://www.haproxy.org/" target="_blank">HAProxy</a> важно изменить один системный параметр.</div></div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">Настройка ОС</h3><div><div>При переезде отказоустойчивого ip на другой хост пришлось бы перезапускать HAProxy, поскольку он бы не прослушивал этот адрес. Исправить эту ситуацию поможет изменение параметра ядра net.ipv4.ip_nonlocal_bind.</div><div><b>Краткое описание:</b></div><div><blockquote>Установка этой переменной позволяет отдельным локальным процессам выступать от имени внешнего (чужого) IP адреса. Это может оказаться полезным в некоторых случаях, когда необходимо прослушивать внешние (чужие) IP адреса, например сниффинг чужого траффика.</blockquote></div><div>Активируем опцию парой команд:</div><div><span style="font-family: courier;"><span style="color: #2b00fe;">echo</span> <span style="color: #38761d;">"net.ipv4.ip_nonlocal_bind=1"</span> <span style="color: #2b00fe;">&gt;&gt;</span> /etc/sysctl.conf</span></div><div><span style="font-family: courier;">sysctl -p</span></div></div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">Настройка HAProxy</h3><div><div>Установим пакет командой:</div><div><span style="font-family: courier;"><span style="color: #2b00fe;">apt-get</span> install haproxy</span></div><div>Забэкапим основной конфиг:</div><div><span style="font-family: courier;">mv /etc/haproxy/haproxy.cfg{,.backup}</span></div><div>Открываем для редактирования новый файл <span style="font-family: courier;">/etc/haproxy/haproxy.cfg</span> и вставляем следующее содержимое (секция global имеет значения по умолчанию, в остальные секции для наглядности включены лишь самые необходимые параметры):</div></div><div><div><span style="font-family: courier;">global</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; log /dev/log&nbsp; &nbsp; local0</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; log /dev/log&nbsp; &nbsp; local1 notice</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; chroot /var/lib/haproxy</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; stats socket /run/haproxy/admin.sock mode 660 level admin</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; stats timeout 30s</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; user haproxy</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; group haproxy</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; daemon</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ca-base /etc/ssl/certs</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; crt-base /etc/ssl/private</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ssl-default-bind-ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:RSA+AESGCM:RSA+AES:!aNULL:!MD5:!DSS</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; ssl-default-bind-options no-sslv3</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">defaults</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; balance roundrobin</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; log&nbsp; &nbsp; &nbsp;global</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; mode&nbsp; &nbsp; tcp</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; option&nbsp; dontlognull</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">frontend fe_exch_443</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; bind 192.168.0.3:443</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; default_backend be_exch_443</span></div><div><span style="font-family: courier;"><br /></span></div><div><span style="font-family: courier;">backend be_exch_443</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; server exch2 192.168.0.102:443 check</span></div><div><span style="font-family: courier;">&nbsp; &nbsp; &nbsp; &nbsp; server exch1 192.168.0.101:443 check</span></div></div><div>Напомню, что балансировка осуществляется на 4 уровне, о чем явно говорит строка конфига — mode tcp. Алгоритм балансировки — простой <i>round robin (balance roundrobin)</i> с проверкой доступности каждого хоста бэкэнда <i>(check)</i>.</div><div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">Тестирование HAProxy</h3><div>Тестирование HAProxy на этом этапе очень похоже на тестирование Ucarp, только в этом случае проверять нужно не только доступность адреса утилитой ping, но и доступность конечного сервиса, подключения которого собственно и балансируются.</div><div>По очереди перезагружайте виртуальные машины и тестируйте доступность сервиса.</div><h3 style="text-align: left;"><br /></h3><h3 style="text-align: left;">Область применения</h3><div>Рассмотренный в статье вариант конфигурации применим к любым сервисам, которые умеют работать с балансировкой tcp-соединений.</div><div>Если говорить про Exchange, то для Exchange Server 2010 балансировка на 4 уровне не подходит, только 7 уровень.</div><div>Кстати, отсутствие необходимости балансировки на 7 уровне стало одним из основных и самых серьезных архитектурных изменений в Exchange 2013 и последующих версиях.</div><div>Для Exchange 2013/2016 все, однако, не ограничивается балансировкой на 4 уровне. Вы вполне можете использовать и 7 уровень, чтобы отслеживать доступность каждого виртуального каталога на конкретном сервере. Но помните, что на стороне балансировщика это будет затрачивать на порядки больше ресурсов, учтите этот факт при планировании решения.</div></div><div><br /></div><div><a href="https://blog.bissquit.com/unix/prostejshij-otkazoustojchivyj-balansirovshhik-layer-4/" target="_blank">Ссылка на оригинал статьи</a></div><div><br /></div>